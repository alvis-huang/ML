import numpy as np
import pandas as pd
import math
from scipy import stats
from sklearn.utils.multiclass import type_of_target
from pandas import DataFrame,Series,read_csv

WOE_MIN = -20
WOE_MAX = 20


def woe_print(X,y,event=1):
    X1 = np.array(X)
    y = np.array(y)
    res_woe, res_iv, x_cuts = woeArray(X1,y,event=event)
    for i in range(len(res_woe)):
        print res_woe[i],"|".join(res_iv), "|".join(x_cuts)

def woeIV(X,y,event=1):
    X1 = np.array(X)
    y = np.array(y)
    res_woe, res_iv, x_cuts = woeArray(X1,y,event=event)
    res_iv = Series(res_iv,index=X.columns)
    return res_iv


def woeArray(X, y, event):
    '''
    Calculate woe of each feature category and information value
    :param X: 2-D numpy array explanatory features which should be discreted already
    :param y: 1-D numpy array target variable which should be binary
    :param event: value of binary stands for the event to predict
    :return: numpy array of woe dictionaries, each dictionary contains woe values for categories of each feature
             numpy array of information value of each feature
    '''
    check_target_binary(y)
    X1, x_cuts = feature_discretion(X)

    res_woe = []
    res_iv = []
    for i in range(0, X1.shape[-1]):
        x = X1[:, i]
        woe_dict, iv1 = woe_single_x(x, y, event=event)
        res_woe.append(woe_dict)
        res_iv.append(iv1)
    return res_woe, res_iv, x_cuts


def woe_single_x(x, y, event):
    '''
    calculate woe and information for a single feature
    :param x: 1-D numpy starnds for single feature
    :param y: 1-D numpy array target variable
    :param event: value of binary stands for the event to predict
    :return: dictionary contains woe values for categories of this feature
             information value of this feature
    '''
    check_target_binary(y)

    event_total, non_event_total = count_binary(y, event=event)
    x_labels = np.unique(x)
    woe_dict = {}
    iv = 0
    for x1 in x_labels:
        y1 = y[np.where(x == x1)[0]]
        event_count, non_event_count = count_binary(y1, event=event)
        rate_event = 1.0 * event_count / event_total
        rate_non_event = 1.0 * non_event_count / non_event_total
        if rate_event == 0:
            woe1 = WOE_MIN
        elif rate_non_event == 0:
            woe1 = WOE_MAX
        else:
            woe1 = math.log(rate_event / rate_non_event)
        woe_dict[x1] = woe1
        iv += (rate_event - rate_non_event) * woe1
    return woe_dict, iv


def woe_replace(X, woe_arr):
    '''
    replace the explanatory feature categories with its woe value
    :param X: 2-D numpy array explanatory features which should be discreted already
    :param woe_arr: numpy array of woe dictionaries, each dictionary contains woe values for categories of each feature
    :return: the new numpy array in which woe values filled
    '''
    if X.shape[-1] != woe_arr.shape[-1]:
        raise ValueError('WOE dict array length must be equal with features length')

    res = np.copy(X).astype(float)
    idx = 0
    for woe_dict in woe_arr:
        for k in woe_dict.keys():
            woe = woe_dict[k]
            res[:, idx][np.where(res[:, idx] == k)[0]] = woe * 1.0
        idx += 1

    return res


def combined_iv(X, y, masks, event=1):
    '''
    calcute the information vlaue of combination features
    :param X: 2-D numpy array explanatory features which should be discreted already
    :param y: 1-D numpy array target variable
    :param masks: 1-D numpy array of masks stands for which features are included in combination,
                  e.g. np.array([0,0,1,1,1,0,0,0,0,0,1]), the length should be same as features length
    :param event: value of binary stands for the event to predict
    :return: woe dictionary and information value of combined features
    '''
    if masks.shape[-1] != X.shape[-1]:
        raise ValueError('Masks array length must be equal with features length')

    x = X[:, np.where(masks == 1)[0]]
    tmp = []
    for i in range(x.shape[0]):
        tmp.append(combine(x[i, :]))

    dumy = np.array(tmp)
    # dumy_labels = np.unique(dumy)
    woe, iv = woe_single_x(dumy, y, event)
    return woe, iv


def combine(list):
    res = ''
    for item in list:
        res += str(item)
    return res


def count_binary(a, event=1):
    event_count = (a == event).sum()
    non_event_count = a.shape[-1] - event_count
    return event_count, non_event_count


def check_target_binary(y):
    '''
    check if the target variable is binary, raise error if not.
    :param y:
    :return:
    '''
    y_type = type_of_target(y)
    if y_type not in ['binary']:
        raise ValueError('Label type must be binary')


def feature_discretion(X):
    '''
    Discrete the continuous features of input data X, and keep other features unchanged.
    :param X : numpy array
    :return: the numpy array in which all continuous features are discreted
    '''
    temp = []
    x_cuts = []
    for i in range(0, X.shape[-1]):
        x = X[:, i]
        x_type = type_of_target(x)
        if x_type == 'continuous':
            x1, x_cut = discrete(x)
            temp.append(x1)
            x_cuts.append(x_cut)
        else:
            temp.append(x)
            x_cuts.append(np.unique(x))
    return np.array(temp).T, x_cuts


def discrete(x):
    '''
    Discrete the input 1-D numpy array using 5 equal percentiles
    :param x: 1-D numpy array
    :return: discreted 1-D numpy array
    '''
    # res = np.array([0] * x.shape[-1], dtype=int)
    # res[np.isnan(x)] = -1
    # for i in range(10):
    #     point1 = stats.scoreatpercentile(x, i * 10)
    #     point2 = stats.scoreatpercentile(x, (i + 1) * 10)
    #     x1 = x[np.where((x >= point1) & (x <= point2))]
    #     mask = np.in1d(x, x1)
    #     res[mask] = (i + 1)
    x = Series(x)
    try:
        X_qcut = pd.qcut(x, 5)
        res = X_qcut.labels
        x_cut = X_qcut.levels.values
    except:
        xlab = [x.quantile(i) for i in [i/10.0 for i in range(0,10,1)]]
        xlab_u = pd.unique(xlab)
        x_cut = pd.cut(x,xlab_u,right=True,include_lowest=True).levels.values
        res = pd.cut(x,xlab_u,right=True,include_lowest=True).labels

    return res, x_cut

if __name__ == '__main__':
    tdata = DataFrame({'x1':[np.nan,0,0,0,0,0,0,0,0,0,0,0,1,1,1,2,2,4,4,4],'y':[1,1,0,1,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0]})
    #tdata = read_csv('testdata.csv')
    res_iv = woeIV(tdata.ix[:,:-1],tdata.ix[:,-1])
    woe_print(tdata)
